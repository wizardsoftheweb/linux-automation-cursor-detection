{% from 'includes/shell_session.j2' import shell_session %}

{% block lead_paragraph %}
{# I'm a huge fan of [AutoHotkey](https://autohotkey.com/). It's been an integral part of my computing world since undergrad. Scripting rote activities is both a load off my back and usually way more fun than actually doing the task. Unfortunately, AutoHotkey is built around the Windows ecosystem, so it's not portable.  #}

{# I spent a considerable amount of time last year  #}

{# I was messing around with some automation this weekend and ran into  #}

I've been absolutely thrilled moving my home dev world back to Fedora. I'm not fighting OS ads, virtualization just works, and my settings actually stay the same after updates. I am, however, missing [AutoHotkey](https://autohotkey.com/). It's been an integral part of my computing world since undergrad. I've spent the better part of three years looking for a POSIX AHK clone with no luck.

I've tossed around the idea of starting something similar for some time now. Obviously I don't have the expertise to make anything near as streamlined as AHK, but I do have the muleheadness to spend an entire weekend trying to bum a word or two from an `awk` chain. Tenacity is a useful trait when you have absolutely no idea what you're doing.
{% endblock %}

{% include 'includes/front_matter.j2' %}

{% block content %}

## Background

Several months ago I began drafting a project along these lines. I think [RobotJS](http://robotjs.io/) is pretty neat, and I've been looking for an excuse to use it. Bundling it via [Electron](https://electronjs.org/) would make the result consumable everywhere, so sidestepping the AHK-proprietary concern.

However, Electron is a Chromium wrapper. It's got a ton of bloat and the whole Chromium thing to worry about. I typically hit my macros pretty hard, so an app that has to juggle many intensive GUI actions while being an intensive GUI might not be the best. (Note: I didn't actually pursue this, so I could be totally wrong and Electron might be faster.) I decided to mess around with a few other ideas this weekend.

## Software

I mention this software during this post. I install everything here, but I remove some of it later. YMMV. If you're in the Debian ecosystem, this should work but the packages will probably have completely different names.

* [`xdotool` and its dependencies](http://www.semicomplete.com/projects/xdotool/)
    {{
        shell_session("$ sudo dnf install xdotool")
    }}
* [ImageMagick](https://www.imagemagick.org/script/download.php)
    {{
        shell_session("$ sudo dnf install ImageMagick")
    }}
* `xwd`: You might have to hunt for this executable's provider.
    {{
        shell_session("""\
$ dnf provides xwd
Last metadata expiration check: 0:10:01 ago on Sun 14 Jan 2018 06:28:40 AM UTC.
xorg-x11-apps-7.7-18.fc27.x86_64 : X.Org X11 applications
Repo        : fedora
Matched from:
Provide    : xwd = 1.0.6

$ sudo dnf install xorg-x11-apps
""")
    }}
* Depending on your Python setup, you might already have these external dependencies.

    {{
        shell_session("""\
$ sudo dnf install \\
        python{2,3}-{tkinter,xlib} \\
        scrot
""")
    }}

* Finally, for good measure, check the `pip` dependencies:

    {{
        shell_session("""\
$ pip install --user \\
        pyautogui \\
        Xlib
""")
    }}

## My First Cursor Position

You can't automate the mouse if you don't know where it is. `xdotool` provides fast and easy access to the cursor (among other things!).

{{
    shell_session("""\
$ xdotool getmouselocation
x:2478 y:1603 screen:0 window:48234503
$ xdotool getmouselocation --shell
X=2468
Y=1265
SCREEN=0
WINDOW=48234503
$ eval $(xdotool getmouselocation --shell); echo $X
2468
$ eval $(xdotool getmouselocation --shell); echo $X
2873
$ eval $(xdotool getmouselocation --shell); echo $X
2456
""")
}}

The only downside is trying to consume this. It might be a better idea to try native options.

## `pyautogui`

`pyautogui` is one of those native options. Al Sweigart wrote [a great little intro](https://automatetheboringstuff.com/chapter18/) that I highly recommend reading. The tool is simple and fast, which is what we're looking for.

{{
    highlight_block(
        join('scripts', 'pyautogui-geometry.py'),
        blob_path=join('scripts', 'pyautogui-geometry.py'),
        explicit_lexer_name = 'PythonLexer',
        title = 'pyautogui-geometry.py'
    )
}}

{{
    shell_session("""\
$ python scripts/pyautogui-geometry.py
Screen: 3000x1920
Mouse: (2570,1597)
Start: 1515917871.17
End: 1515917871.17
Difference: 0.000105142593384
""")
}}

The geometry is blazing fast and super simple. `pyautogui` can also work with the screen and detect images and colors. Detecting color under the cursor is a great way to trigger actions, especially in routine applications.

{{
    highlight_block(
        join('scripts', 'pyautogui-pixel-color.py'),
        blob_path=join('scripts', 'pyautogui-pixel-color.py'),
        explicit_lexer_name = 'PythonLexer',
        title = 'pyautogui-pixel-color.py'
    )
}}

{{
    shell_session("""\
$ python scripts/pyautogui-pixel-color.py
Screen: 3000x1920
Mouse: (2731,1766)
RGB: (20, 21, 22)
Start: 1515918345.91
End: 1515918346.19
Difference: 0.282289028168
""")
}}

Unfortunately, `pyautogui` is super slow. No matter what, it screenshots everything, then returns what you requested.

{{
    highlight_block(
        join('scripts', 'pyautogui-full-vs-region.py'),
        blob_path=join('scripts', 'pyautogui-full-vs-region.py'),
        explicit_lexer_name = 'PythonLexer',
        title = 'pyautogui-pixel-color.py'
    )
}}

{{
    shell_session("""\
$ python scripts/pyautogui-full-vs-region.py
Using a region
Screen: 3000x1920
Mouse: (2416,1456)
RGB: (20, 21, 22)
Start: 1515919266.8
End: 1515919267.09
Difference: 0.286885023117
==========
Full screen
Screen: 3000x1920
Mouse: (2416,1456)
Start: 1515919267.09
End: 1515919267.37
Difference: 0.281718969345
""")
}}

Smaller screens will do better; [the docs mention this](https://pyautogui.readthedocs.io/en/latest/screenshot.html#the-screenshot-function). I was able to cut my time by disabling my second screen. That's neither fun nor practical, so I put `pyautogui` aside for now.

## Frankenstein

I have to admit, I was kinda stumped at this point. `pyautogui` is well-written and seriously vetted. I too would have gone the screenshot route, which means I too would be much too slow. A different approach is necessary, but I don't know what.

Luckily I stumbled into `xwd` via [a wonderfully succinct `bash` solution](https://stackoverflow.com/a/25498342/2877698). It's the [`X` `W`indow `D`umping utility](http://www.xfree86.org/current/xwd.1.html). That's insanely useful here, since X is what runs the system. `xwd`, in theory, has all of the screen information I could want. The linked solution uses ImageMagick [to convert the dump](https://github.com/ImageMagick/ImageMagick/blob/master/coders/xwd.c); not only did I not know it was possible to get an X dump, I also did not know ImageMagick would parse it beautifully (I would have guessed that part eventually).

### `bash`
{{
    highlight_block(
        join('scripts', 'xwd-convert.sh'),
        blob_path=join('scripts', 'xwd-convert.sh'),
        explicit_lexer_name = 'BashLexer',
        external_source_link = 'https://stackoverflow.com/a/25498342/2877698',
        title = 'xwd-convert.sh'
    )
}}

{{
    shell_session("""\
$ scripts/xwd-convert.sh
&num; ImageMagick pixel enumeration: 1,1,65535,srgb
0,0: (5140,5397,5654)  #141516  srgb(20,21,22)
Start: 1515922099742
End: 1515922100086
Difference: 344
""")
}}

That's even slower than `pyautogui`. To be fair, we should probably build it in Python.

{% endblock %}

